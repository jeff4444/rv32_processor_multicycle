$date
	Fri Feb 28 10:28:32 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module tb_processor $end
$var reg 1 ! clk $end
$var reg 1 " resetn $end
$scope module processor $end
$var wire 1 ! clk $end
$var wire 1 # pcWriteReg $end
$var wire 1 " resetn $end
$var wire 1 $ zero $end
$var wire 32 % regWriteData [31:0] $end
$var wire 32 & prevReg2Data [31:0] $end
$var wire 32 ' prevReg1Data [31:0] $end
$var wire 32 ( prevMemData [31:0] $end
$var wire 32 ) pcNext [31:0] $end
$var wire 32 * pcCurr [31:0] $end
$var wire 32 + memData [31:0] $end
$var wire 32 , memAddress [31:0] $end
$var wire 32 - instruction [31:0] $end
$var wire 32 . immediate [31:0] $end
$var wire 32 / curReg2Data [31:0] $end
$var wire 32 0 curReg1Data [31:0] $end
$var wire 4 1 alu_op [3:0] $end
$var wire 1 2 RegWrite $end
$var wire 1 3 PCWriteCond $end
$var wire 1 4 PCWrite $end
$var wire 1 5 PCSource $end
$var wire 1 6 MemtoReg $end
$var wire 1 7 MemWrite $end
$var wire 1 8 MemRead $end
$var wire 1 9 IorD $end
$var wire 1 : IRWrite $end
$var wire 2 ; ALUSrcB [1:0] $end
$var wire 1 < ALUSrcA $end
$var wire 32 = ALUResPrev [31:0] $end
$var wire 32 > ALURes [31:0] $end
$var wire 2 ? ALUOp [1:0] $end
$var wire 32 @ ALUIn2 [31:0] $end
$var wire 32 A ALUIn1 [31:0] $end
$scope module A $end
$var wire 1 ! clk $end
$var wire 1 " resetn $end
$var wire 1 B write $end
$var wire 32 C next [31:0] $end
$var reg 32 D prev [31:0] $end
$upscope $end
$scope module ALU $end
$var wire 1 $ zero $end
$var wire 32 E result [31:0] $end
$var wire 32 F op2 [31:0] $end
$var wire 32 G op1 [31:0] $end
$var wire 4 H alu_op [3:0] $end
$upscope $end
$scope module ALUOut $end
$var wire 1 ! clk $end
$var wire 32 I next [31:0] $end
$var wire 1 " resetn $end
$var wire 1 J write $end
$var reg 32 K prev [31:0] $end
$upscope $end
$scope module B $end
$var wire 1 ! clk $end
$var wire 1 " resetn $end
$var wire 1 L write $end
$var wire 32 M next [31:0] $end
$var reg 32 N prev [31:0] $end
$upscope $end
$scope module PC $end
$var wire 1 ! clk $end
$var wire 1 " resetn $end
$var wire 1 # write $end
$var wire 32 O next [31:0] $end
$var reg 32 P prev [31:0] $end
$upscope $end
$scope module aluCtrl $end
$var wire 32 Q instruction [31:0] $end
$var wire 2 R alu_op_sel [1:0] $end
$var wire 4 S alu_op [3:0] $end
$upscope $end
$scope module ctrl $end
$var wire 1 ! clk $end
$var wire 7 T opcode [6:0] $end
$var wire 1 " resetn $end
$var reg 2 U ALUOp [1:0] $end
$var reg 1 < ALUSrcA $end
$var reg 2 V ALUSrcB [1:0] $end
$var reg 1 : IRWrite $end
$var reg 1 9 IorD $end
$var reg 1 8 MemRead $end
$var reg 1 7 MemWrite $end
$var reg 1 6 MemtoReg $end
$var reg 1 5 PCSource $end
$var reg 1 4 PCWrite $end
$var reg 1 3 PCWriteCond $end
$var reg 1 2 RegWrite $end
$var reg 4 W cur_state [3:0] $end
$var reg 4 X next_state [3:0] $end
$upscope $end
$scope module immGen $end
$var wire 32 Y instruction [31:0] $end
$var wire 32 Z immediate [31:0] $end
$var reg 12 [ temp_imm [11:0] $end
$upscope $end
$scope module instructionReg $end
$var wire 1 ! clk $end
$var wire 1 " resetn $end
$var wire 1 : write $end
$var wire 32 \ next [31:0] $end
$var reg 32 ] prev [31:0] $end
$upscope $end
$scope module mem $end
$var wire 1 ! clk $end
$var wire 1 8 memRead $end
$var wire 1 7 memWrite $end
$var wire 1 " resetn $end
$var wire 32 ^ writeData [31:0] $end
$var wire 32 _ address [31:0] $end
$var reg 32 ` memData [31:0] $end
$scope begin $ivl_for_loop1 $end
$var integer 32 a i [31:0] $end
$upscope $end
$upscope $end
$scope module memDataReg $end
$var wire 1 ! clk $end
$var wire 32 b next [31:0] $end
$var wire 1 " resetn $end
$var wire 1 c write $end
$var reg 32 d prev [31:0] $end
$upscope $end
$scope module mux1 $end
$var wire 32 e op1 [31:0] $end
$var wire 32 f op2 [31:0] $end
$var wire 1 9 sel $end
$var wire 32 g out [31:0] $end
$upscope $end
$scope module mux2 $end
$var wire 32 h op1 [31:0] $end
$var wire 32 i op2 [31:0] $end
$var wire 1 6 sel $end
$var wire 32 j out [31:0] $end
$upscope $end
$scope module mux3 $end
$var wire 32 k op1 [31:0] $end
$var wire 32 l op2 [31:0] $end
$var wire 1 < sel $end
$var wire 32 m out [31:0] $end
$upscope $end
$scope module mux4 $end
$var wire 32 n in0 [31:0] $end
$var wire 32 o in1 [31:0] $end
$var wire 32 p in2 [31:0] $end
$var wire 32 q in3 [31:0] $end
$var wire 2 r sel [1:0] $end
$var reg 32 s out [31:0] $end
$upscope $end
$scope module mux5 $end
$var wire 32 t op1 [31:0] $end
$var wire 32 u op2 [31:0] $end
$var wire 1 5 sel $end
$var wire 32 v out [31:0] $end
$upscope $end
$scope module regFile $end
$var wire 1 ! clk $end
$var wire 32 w readData1 [31:0] $end
$var wire 32 x readData2 [31:0] $end
$var wire 5 y readReg1 [4:0] $end
$var wire 5 z readReg2 [4:0] $end
$var wire 1 2 regWrite $end
$var wire 1 " resetn $end
$var wire 32 { writeData [31:0] $end
$var wire 5 | writeReg [4:0] $end
$scope begin $ivl_for_loop0 $end
$var integer 32 } i [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
$end
#0
$dumpvars
bx }
bx |
bx {
bx z
bx y
bx x
bx w
bx v
bx u
bx t
b0x s
bx r
b0 q
bx p
b100 o
bx n
bx m
bx l
bx k
bx j
bx i
bx h
bx g
bx f
bx e
bx d
1c
bx b
bx a
bx `
bx _
bx ^
bx ]
bx \
bx [
bx Z
bx Y
bx X
bx W
bx V
bx U
bx T
b0xxx S
bx R
bx Q
bx P
bx O
bx N
bx M
1L
bx K
1J
bx I
b0xxx H
bx G
b0x F
bx E
bx D
bx C
1B
bx A
b0x @
bx ?
bx >
bx =
x<
bx ;
x:
x9
x8
x7
x6
x5
x4
x3
x2
b0xxx 1
bx 0
bx /
bx .
bx -
bx ,
bx +
bx *
bx )
bx (
bx '
bx &
bx %
x$
x#
0"
0!
$end
#5000
b0x10 1
b0x10 H
b0x10 S
b0 .
b0 Z
b0 p
b0 |
b0 /
b0 M
b0 x
b0 z
b0 0
b0 C
b0 w
b0 y
b0 T
b0 [
b0 A
b0 G
b0 m
b0 ,
b0 _
b0 g
b0 %
b0 j
b0 {
b0 *
b0 P
b0 e
b0 k
b0 -
b0 Q
b0 Y
b0 ]
b0 (
b0 d
b0 i
b0 W
b0 X
b0 '
b0 D
b0 l
b0 &
b0 N
b0 ^
b0 n
b0 =
b0 K
b0 f
b0 h
b0 u
b100000 }
b10000000000 a
1!
#10000
0!
1"
#15000
b100 )
b100 O
b100 v
0$
b100 >
b100 E
b100 I
b100 t
b10 1
b10 H
b10 S
1#
b100 @
b100 F
b100 s
bx %
bx j
bx {
bx =
bx K
bx f
bx h
bx u
05
02
07
06
03
14
b0 ?
b0 R
b0 U
b1 ;
b1 V
b1 r
1:
09
0<
18
b1 X
bx (
bx d
bx i
1!
#20000
0!
#25000
b1000 )
b1000 O
b1000 v
b1000 >
b1000 E
b1000 I
b1000 t
bx0000000000000 .
bx0000000000000 Z
bx0000000000000 p
b100 ,
b100 _
b100 g
b100 A
b100 G
b100 m
bx |
bx /
bx M
bx x
bx z
bx 0
bx C
bx w
bx y
bx T
b100 %
b100 j
b100 {
b10000010000011 +
b10000010000011 \
b10000010000011 `
b10000010000011 b
b100 *
b100 P
b100 e
b100 k
bx -
bx Q
bx Y
bx ]
b1 W
b100 =
b100 K
b100 f
b100 h
b100 u
1!
#30000
0!
#35000
b1000 )
b1000 O
b1000 v
0$
b1000 >
b1000 E
b1000 I
b1000 t
b0 .
b0 Z
b0 p
b1000 %
b1000 j
b1000 {
0#
b0 @
b0 F
b0 s
b1 |
b0 /
b0 M
b0 x
b0 z
b0 0
b0 C
b0 w
b0 y
b11 T
b1000 ,
b1000 _
b1000 g
b1000 A
b1000 G
b1000 m
b1000 =
b1000 K
b1000 f
b1000 h
b1000 u
bx &
bx N
bx ^
bx n
bx '
bx D
bx l
04
b10 ;
b10 V
b10 r
0:
08
b10000010000011 (
b10000010000011 d
b10000010000011 i
b10000010000011 -
b10000010000011 Q
b10000010000011 Y
b10000010000011 ]
b1000 *
b1000 P
b1000 e
b1000 k
b100001000000100110011 +
b100001000000100110011 \
b100001000000100110011 `
b100001000000100110011 b
1!
#40000
0!
#45000
b100001000000100110011 (
b100001000000100110011 d
b100001000000100110011 i
b10 X
b0 '
b0 D
b0 l
b0 &
b0 N
b0 ^
b0 n
1!
#50000
0!
#55000
b10 W
1!
#60000
0!
#65000
b0 )
b0 O
b0 v
1$
b0 >
b0 E
b0 I
b0 t
b0 A
b0 G
b0 m
b11 X
1<
1!
#70000
0!
#75000
b0 %
b0 j
b0 {
b0 =
b0 K
b0 f
b0 h
b0 u
b11 W
1!
#80000
0!
#85000
b1000 )
b1000 O
b1000 v
0$
b1000 >
b1000 E
b1000 I
b1000 t
b0 ,
b0 _
b0 g
b1000 A
b1000 G
b1000 m
b100 X
b0 ;
b0 V
b0 r
19
0<
18
1!
#90000
0!
#95000
b1000 ,
b1000 _
b1000 g
b1000 %
b1000 j
b1000 {
b1000 =
b1000 K
b1000 f
b1000 h
b1000 u
b100 W
b10000010000011 +
b10000010000011 \
b10000010000011 `
b10000010000011 b
1!
#100000
0!
#105000
b10000010000011 %
b10000010000011 j
b10000010000011 {
b1000001000000110110011 +
b1000001000000110110011 \
b1000001000000110110011 `
b1000001000000110110011 b
b10000010000011 (
b10000010000011 d
b10000010000011 i
b0 X
12
16
09
08
1!
#110000
0!
#115000
b1000001000000110110011 %
b1000001000000110110011 j
b1000001000000110110011 {
b0 W
b1000001000000110110011 (
b1000001000000110110011 d
b1000001000000110110011 i
1!
#120000
0!
#125000
b1100 )
b1100 O
b1100 v
b1100 >
b1100 E
b1100 I
b1100 t
b1000 %
b1000 j
b1000 {
1#
b100 @
b100 F
b100 s
b1 X
02
06
14
b1 ;
b1 V
b1 r
1:
18
1!
#130000
0!
#135000
b10000 )
b10000 O
b10000 v
b10000 >
b10000 E
b10000 I
b10000 t
b1100 %
b1100 j
b1100 {
b11 |
b10 z
b1000001000000110110011 0
b1000001000000110110011 C
b1000001000000110110011 w
b1 y
b110011 T
b1100 ,
b1100 _
b1100 g
b1100 A
b1100 G
b1100 m
b1100 =
b1100 K
b1100 f
b1100 h
b1100 u
b1 W
b1000001000000110110011 -
b1000001000000110110011 Q
b1000001000000110110011 Y
b1000001000000110110011 ]
b1100 *
b1100 P
b1100 e
b1100 k
1!
#140000
0!
#145000
b10000 ,
b10000 _
b10000 g
b10000 A
b10000 G
b10000 m
0#
b0 @
b0 F
b0 s
b10000 %
b10000 j
b10000 {
b1000000000100011000001000110011 +
b1000000000100011000001000110011 \
b1000000000100011000001000110011 `
b1000000000100011000001000110011 b
b10000 *
b10000 P
b10000 e
b10000 k
b110 X
04
b10 ;
b10 V
b10 r
0:
08
b1000001000000110110011 '
b1000001000000110110011 D
b1000001000000110110011 l
b10000 =
b10000 K
b10000 f
b10000 h
b10000 u
1!
#150000
0!
#155000
b110 W
b1000000000100011000001000110011 (
b1000000000100011000001000110011 d
b1000000000100011000001000110011 i
1!
#160000
0!
#165000
b1000001000000110110011 )
b1000001000000110110011 O
b1000001000000110110011 v
b1000001000000110110011 >
b1000001000000110110011 E
b1000001000000110110011 I
b1000001000000110110011 t
b1000001000000110110011 A
b1000001000000110110011 G
b1000001000000110110011 m
b111 X
b10 ?
b10 R
b10 U
b0 ;
b0 V
b0 r
1<
1!
#170000
0!
#175000
b1000001000000110110011 %
b1000001000000110110011 j
b1000001000000110110011 {
b1000001000000110110011 =
b1000001000000110110011 K
b1000001000000110110011 f
b1000001000000110110011 h
b1000001000000110110011 u
b111 W
1!
#180000
0!
#185000
b10000 )
b10000 O
b10000 v
b10000 >
b10000 E
b10000 I
b10000 t
b10000 A
b10000 G
b10000 m
b0 X
12
b0 ?
b0 R
b0 U
0<
1!
#190000
0!
#195000
b10000 %
b10000 j
b10000 {
b10000 =
b10000 K
b10000 f
b10000 h
b10000 u
b0 W
1!
#200000
0!
#205000
b10100 )
b10100 O
b10100 v
b10100 >
b10100 E
b10100 I
b10100 t
1#
b100 @
b100 F
b100 s
b1 X
02
14
b1 ;
b1 V
b1 r
1:
18
1!
#210000
0!
#215000
b11000 )
b11000 O
b11000 v
b11000 >
b11000 E
b11000 I
b11000 t
b10100 %
b10100 j
b10100 {
b100 |
b1000001000000110110011 /
b1000001000000110110011 M
b1000001000000110110011 x
b1 z
b10000 0
b10000 C
b10000 w
b11 y
b10100 ,
b10100 _
b10100 g
b10100 A
b10100 G
b10100 m
b10100 =
b10100 K
b10100 f
b10100 h
b10100 u
b1 W
b1000000000100011000001000110011 -
b1000000000100011000001000110011 Q
b1000000000100011000001000110011 Y
b1000000000100011000001000110011 ]
b10100 *
b10100 P
b10100 e
b10100 k
b100100111001010110011 +
b100100111001010110011 \
b100100111001010110011 `
b100100111001010110011 b
1!
#220000
0!
#225000
b11000 ,
b11000 _
b11000 g
b11000 A
b11000 G
b11000 m
b101 |
b0 0
b0 C
b0 w
b100 y
0#
b0 @
b0 F
b0 s
b11000 %
b11000 j
b11000 {
b100011110001100110011 +
b100011110001100110011 \
b100011110001100110011 `
b100011110001100110011 b
b11000 *
b11000 P
b11000 e
b11000 k
b100100111001010110011 -
b100100111001010110011 Q
b100100111001010110011 Y
b100100111001010110011 ]
b100100111001010110011 (
b100100111001010110011 d
b100100111001010110011 i
b110 X
04
b10 ;
b10 V
b10 r
0:
08
b10000 '
b10000 D
b10000 l
b1000001000000110110011 &
b1000001000000110110011 N
b1000001000000110110011 ^
b1000001000000110110011 n
b11000 =
b11000 K
b11000 f
b11000 h
b11000 u
1!
#230000
0!
#235000
b0 '
b0 D
b0 l
b110 W
b100011110001100110011 (
b100011110001100110011 d
b100011110001100110011 i
1!
#240000
0!
#245000
b0 )
b0 O
b0 v
1$
b0 >
b0 E
b0 I
b0 t
b0 1
b0 H
b0 S
b1000001000000110110011 @
b1000001000000110110011 F
b1000001000000110110011 s
b0 A
b0 G
b0 m
b111 X
b10 ?
b10 R
b10 U
b0 ;
b0 V
b0 r
1<
1!
#250000
0!
#255000
b0 %
b0 j
b0 {
b0 =
b0 K
b0 f
b0 h
b0 u
b111 W
1!
#260000
0!
